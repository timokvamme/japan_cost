# -*- coding: utf-8 -*-
"""
Symmetry Span task, a la Foster et al (2015).
Written by Jonas Lindeløv, Aug 2015

TO DO:
 * Check that fields generated by CS code are in create_trial_list
 * Add information about training day, time since last training day etc.
 * Add trial-number
 
"""
from __future__ import division
import glob, os, random
import numpy as np
from psychopy import visual, event, core, gui, monitors

# Monitor
MON_SIZE = [1366, 768]  # monitor size in pixels
MON_DISTANCE = 70  # distance in cm from eye lens to monitor
MON_WIDTH = 34  # width of monitor panel in cm

# Conditions
SPANS_TEST = [2, 3, 4, 5, 6, 7]
N_REPS = 3  # how many times to repeat each span lenght during tests
BLOCK_LENGTH = 10  # number of trials per block

# Training
TIME_TRAINING = 60*30  # duration of training in seconds
DOWNGRADE_CRITERION = 0.67  # percentage of correct recalls in trial below which subjects are downgraded
UPGRADE_CRITERION = 0.80  # percentage of correct recalls in trial above which subjects are upgraded

# Filename stuff
SYMM_FOLDER = 'symmetries'
CARD_FOLDER = 'cards'
ASYM_START_TRIAL = 25  # 1-24 are symmetrical, 25+ are asymmetrical
ASYM_START_PRACTICE = 8
SAVE_FOLDER = 'data'

# Stimuli
RECALL_DIMENSIONS_LOCATION = (4, 4)  # [x, y], number of cells in grid
GRID_SIZE = 1  # degrees visual angle of each cell
GRID_DURATION = 45  # duration on screen
GRID_PAUSE = 15  # duration before recall
SYMM_PAUSE = 15
TRIAL_PAUSE = 60  # pause in beginning of trial
BUTTON_STYLE = {'fillColor':'LightGray', 'lineColor':None, 'interpolate':False}
FEEDBACK_DURATION = 120  # duration of feedback after finished trial
TEXT_HEIGHT = 0.5

RECALL_DIMENSIONS_CARD = [4, 3]
RECALL_CARD_SIZE = 3
RECALL_CARD_SPACING = 1.25  # a factor
RECALL_CARD_CENTER = [0, 0]

# Keys
KEYS_QUIT = ['escape']

# Instructions during experiment
TEXT_RECALL = u'Vælg felterne i den rækkefølge, de blev vist. Brug TOM knappen til glemte placeringer.'
TEXT_FEEDBACK_GRID = u'Du huskede %i placeringer korrekt ud af %i.\n'
TEXT_FEEDBACK_SYMMETRY = u'Du lavede %i symmetrifejl. '
TEXT_FEEDBACK_PERCENT = 'Symmetri-korrekthed: %i%%.'
TEXT_CONTINUE = u'\n\nTryk med musen for at forstætte. '
TEXT_ASK = u'Spørg venligst, hvis du er i tvivl om noget.'


# Instructions for practice
INSTRUCT_WELCOME1 = u"""
I dette eksperiment skal du huske placeringen af farvede firkanter på skærmen, samtidig med at du foretager vurderinger af nogle billeder.

I de næste minutter får du nogle øvelser, som gør dig bekendt med, hvordan eksperimentet fungerer.

Vi begynder med at øve "placering" delen af eksperimentet.""" + TEXT_CONTINUE
INSTRUCT_RECALL1 = u"""
I dette øvelsessæt vil firkanterne blive vist én ad gangen på skærmen.

Prøv at huske hvor hver firkant var, i den rækkefølge de blev præsenteret i.

Efter at 2-5 firkanter er vist, vil du se et gitter med de 16 mulige placeringer hvor firkanterne kunne have været.

Din opgave er at vælge hver placering i den rækkefølge, de blev præsenteret. Klik med musen på de passende felter. Det valgte felt bliver rødt.""" + TEXT_CONTINUE
INSTRUCT_RECALL2 = u"""
Når du har valgt alle firkanterne i den rigtige rækkefølge, tryk på SVAR knappen nederst til højre på skærmen.

Tryk på SLET ALT knappen hvis du laver en fejl og begynd så forfra.

Tryk på TOM hvis du glemmer en af placeringerne for at markere hvor i rækkefølgen du har glemt.

Husk, det er meget vigtigt at markere placeringerne i samme rækkefølge, som du ser dem. Hvis du glemmer én, så brug TOM knappen til at markere stedet i rækkefølgen.""" + TEXT_CONTINUE + TEXT_ASK
INSTRUCT_SYMMETRY1 = u"""
Nu skal du øve symmetri-delen af eksperimentet.

Der bliver vist et billede på skærmen, og du skal svare, om det er symmetrisk. Et billede er symmetrisk hvis det kan foldes langs en lodret midterlinje og den venstre del passer med den højre del. Med andre ord, billedet er symmetrisk hvis venstre og højre side er hinandens spejlbilleder. På næste skærm ser du et billede der ER SYMMETRISK.""" + TEXT_CONTINUE
INSTRUCT_SYMMETRY2 = u"""
Bemærk at dette billede er symmetrisk om den røde linje

Senere vil der ikke blive vist en rød linje.""" + TEXT_CONTINUE
INSTRUCT_SYMMETRY3 = u"""
Dette billede er IKKE symmetrisk.

Hvis du foldede dette billede langs den røde linje, ville boksene IKKE passe sammen.""" + TEXT_CONTINUE
INSTRUCT_SYMMETRY4 = u"""
Dette er et andet eksempel på et billede, der ER symmetrisk.

Hvis du foldede det vertikalt, ville de to sider passe sammen.""" + TEXT_CONTINUE
INSTRUCT_SYMMETRY5 = u"""
På næste skærmbillede vises endnu et symmetri-problem. 

Tryk på musen, når du har set, om billedet er symmetrisk. Når du trykker, vises der herefter en JA knap og et NEJ knap. Klik på JA knappen hvis billedet, du så, var symmetrisk. Klik på NEJ knappen hvis billedet ikke var symmetrisk.

Efter at du har klikket på en af boksene vil computeren fortælle dig, om du valgte rigtigt.

Det er MEGET vigtigt at du svarer korrekt på billederne.""" + TEXT_CONTINUE + TEXT_ASK
INSTRUCT_TASK1 = u"""
Du skal nu øve begge dele af eksperimentet på én gang.

I de næste øvelser bliver du vist en af symmetriopgaverne. Når du har truffet dit valg om billedet, vil en firkant-placering blive vist på skærmen. Prøv at huske placeringen af firkanten.

I de tidligere symmetriproblemer beregnede computeren den gennemsnitlige tid det tog for dig at løse problemerne. Hvis du bruger længere end denne tid, vil computeren automatisk gå videre til firkant-delen, uden at spørge JA/NEJ til symmetri-problemet, og registrere det som en fejl. Det er derfor MEGET vigtigt at løse problemet så hurtigt og præcist som muligt.""" + TEXT_CONTINUE
INSTRUCT_TASK2 = u"""
Efter firkanten forsvinder, vises der et andet symmetri-billede og igen en anden firkant.

Efter denne række af billeder og firkanter skal du svare, hvilke placeringer firkanten blev vist på. Brug musen til at vælge disse placeringer. Gør dit bedste for at få firkanterne markeret i den rigtige rækkefølge.

Det er vigtigt at du arbejder HURTIGT og PRÆCIST.

Du vil ikke få at vide, om dit svar til symmetri-billedet var korrekt.

Efter du har svaret hvor firkanterne var, vil du dog få feedback på din præstation, både med antallet af firkanter og procent korrekthed på symmetri-problemerne.""" + TEXT_CONTINUE + TEXT_ASK
INSTRUCT_TASK3 = u"""
Under feedbacken er der et rødt tal i øverste højre hjørne af skærmen.

Det viser hvor mange procent af symmetriproblemerne du har løst korrekt igennem hele eksperimentet.

Det er MEGET vigtigt, at du holder dette tal på mindst 85%

Vi kan kun bruge dine data hvis du har mindst 85% korrekt på symmetri-billederne. Derfor skal du svare rigtigt på mindst 85% af symmetri-billederne SAMTIDIGT med at du gør dit bedste for at huske så mange firkanter som muligt.""" + TEXT_CONTINUE + TEXT_ASK
INSTRUCT_EXPERIMENT = u"""
Øvelserne er slut nu.

Det rigtige eksperiment er ligesom de øvelser du netop har gennemgået. Nogle symmetri-firkant sekvenser er længere end andre.

Det er vigtigt, at du gør dit bedste på både symmetri- og firkant-opgaverne.

Husk også at holde din symmetri-korrekthed over 85%.""" + TEXT_CONTINUE
INSTRUCT_BYE = u'Opgaven er slut. Tak for din deltagelse!'


"""
PSYCHOPY STIMS'N STUFF
"""

# Dialogue box
DIALOGUE = {'id':'', 'session':[1, 2, 3, 4, 5, 6, 7], 'stimType': ['card', 'location'], 'run_part':['instructionText', 'test', 'training']}
if not gui.DlgFromDict(DIALOGUE, order=['id', 'session']).OK:
    core.quit()

# Window
monitor = monitors.Monitor('testMonitor', width=MON_WIDTH, distance=MON_DISTANCE)  # Create monitor object from the variables above. This is needed to control size of stimuli in degrees.
monitor.setSizePix(MON_SIZE)
win = visual.Window(monitor=monitor, units='deg', color='black', fullscr=True, waitBlanking=False)

# Stuff for instructions
instruct_center = visual.TextStim(win, color='white', height=TEXT_HEIGHT)
instruct_bottom = visual.TextStim(win, color='white', height=TEXT_HEIGHT, pos=(0, -3))
instruct_image = visual.ImageStim(win, pos=(0, 3))
feedback_percent = visual.TextStim(win, text='', color='red', pos=(0,-3), height=TEXT_HEIGHT)

# Grid stims
text_target = visual.TextStim(win, height=GRID_SIZE*0.5, color='white')
square_target = visual.Rect(win, height=GRID_SIZE, width=GRID_SIZE, lineColor='white', lineWidth=2, fillColor='red', interpolate=False)

square_grid = visual.Rect(win, height=GRID_SIZE, width=GRID_SIZE, lineColor='white', lineWidth=2, interpolate=False)
grid_coords = []
for y in range(RECALL_DIMENSIONS_LOCATION[1] -1, -1, -1):  # from top to bottom
    for x in range(RECALL_DIMENSIONS_LOCATION[0]):  # left to right
        grid_coords += [(GRID_SIZE*(x + 0.5 - 0.5*RECALL_DIMENSIONS_LOCATION[0]), 
                         GRID_SIZE*(y + 0.5 - 0.5*RECALL_DIMENSIONS_LOCATION[1]))]
        square_grid.pos = grid_coords[-1]  # set to this x, y coordinate
        square_grid.draw()
grid = visual.BufferImageStim(win)  # "screenshot"
win.clearBuffer()  # blank screen - we don't want to show it later

# Symmetry task response screen. Rect-buttons will be used to detect presses
symm_button_yes = visual.Rect(win, pos=(-3, 0), width=4, height=2.5, **BUTTON_STYLE)
symm_button_no = visual.Rect(win, pos=(3, 0), width=4, height=2.5, **BUTTON_STYLE)
symm_stims = [
    symm_button_yes,
    symm_button_no,
    visual.TextStim(win, pos=(-3, 0), text='Ja', height=TEXT_HEIGHT, color='black'),
    visual.TextStim(win, pos=(3, 0), text='Nej', height=TEXT_HEIGHT, color='black')]
screen_symmetry = visual.BufferImageStim(win, stim=symm_stims)

# Buttons screenshot
y_offset = 1.5*GRID_SIZE*RECALL_DIMENSIONS_LOCATION[1]/2 if DIALOGUE['stimType'] == 'location' else 1.5*RECALL_DIMENSIONS_CARD[1]*RECALL_CARD_SIZE / 2
recall_button_clear = visual.Rect(win, pos=(-3, -y_offset), width=2.5, height=1.5, **BUTTON_STYLE)
recall_button_respond = visual.Rect(win, pos=(3, -y_offset), width=2.5, height=1.5, **BUTTON_STYLE)
recall_button_blank = visual.Rect(win, pos=(0, -y_offset), width=2.5, height=1.5, **BUTTON_STYLE)

button_stims = [
    recall_button_clear, 
    recall_button_respond, 
    recall_button_blank,
    visual.TextStim(win, pos=(-3, -y_offset), text=u'SLET ALT', height=0.5, color='black'),
    visual.TextStim(win, pos=(0, -y_offset), text=u'INDSÆT\nTOM', height=0.5, color='black'),
    visual.TextStim(win, pos=(3, -y_offset), text=u'SVAR', height=0.5, color='black')
]
screen_buttons = visual.BufferImageStim(win, stim=button_stims)

# Response screen for location
resp_loc_stims = [grid] + button_stims + [visual.TextStim(win, text=TEXT_RECALL, color='white', height=TEXT_HEIGHT, pos=(0, y_offset))]
screen_recall_grid = visual.BufferImageStim(win, stim=resp_loc_stims)

# Response screen for card
textRecall = visual.TextStim(win, height=0.4, pos=(0, y_offset), color='white')

# Stuff for the cards recall screen
recallOption = visual.ImageStim(win, image='cards/2_of_clubs.png')  # each face during recall
recallOption.size *= RECALL_CARD_SIZE / max(recallOption.size)
recallSelectedOverlay = visual.Rect(win, lineWidth=0, fillColor='green', opacity=0.5, width=recallOption.size[0], height=recallOption.size[1])  # green filter over selection
recallSelectedNumber = visual.TextStim(win, color='white', height=0.8)  # indicating sequence during recall

gridCoords = []
for y in range(RECALL_DIMENSIONS_CARD[1] -1, -1, -1):  # from top to bottom
    for x in range(RECALL_DIMENSIONS_CARD[0]):
        gridCoords += [[x * recallOption.size[0] * RECALL_CARD_SPACING, y * recallOption.size[1] * RECALL_CARD_SPACING]]
gridCoords = gridCoords - np.mean(gridCoords, axis=0)  # center
gridCoords += RECALL_CARD_CENTER  # shift position




# Other psychopy stuff
mouse = event.Mouse()
clock = core.Clock()
clock_absolute = core.Clock()

# A list of image-stimuli which can be used for the symmetry span task.
# We do it this so that we can load all images before each trial in order 
# to minimize processing during presentation.
stim_symm = [visual.ImageStim(win, size=(4*3, 3*3)) for i in range(20)]
for stim in stim_symm:
    stim.color *= -1
stim_card = [visual.ImageStim(win, size=(5.00, 7.26)) for i in range(20)]

# Register image files according to their type
stims_symm = {
    'examples': sorted(glob.glob(os.path.join(SYMM_FOLDER, 'example_*'))),
    'matrices': sorted(glob.glob(os.path.join(SYMM_FOLDER, 'matrix*'))),
    'practice': sorted(glob.glob(os.path.join(SYMM_FOLDER, 'pracsymm*'))),
    'pattern_all': sorted(glob.glob(os.path.join(SYMM_FOLDER, 'symm*')))
}
stims_cards = sorted(glob.glob(os.path.join(CARD_FOLDER, '*.png')))

# Update "stims" with the image ID
for stim_type in stims_symm:
    for i, filename in enumerate(stims_symm[stim_type]):
        stims_symm[stim_type][i] = {'recording_filename': filename, 'id': int(filter(str.isdigit, filename))}


"""
FUNCTIONS
"""
def make_trial(span_level=None, run_section=None):
    """ Generates a single trial"""
    # Add unpredictability to span
    if DIALOGUE['run_part'] == 'training':
        span_trial = span_level + random.choice([-1, 0, 1])
    else:
        span_trial = span_level
    
    # Select some patterns
    patterns_loop = stims_symm['practice'] if DIALOGUE['run_part'] == 'instructionText' else stims_symm['pattern_all']
    patterns_trial = random.sample(patterns_loop, span_trial)
    
    # Build trial info
    trial = {
        # General
        'condition': 'experiment' if span_level is None else 'practice',
        'span': span_trial,
        'no': '',
        'id': DIALOGUE['id'],
        'session': DIALOGUE['session'],
        'stimType': DIALOGUE['stimType'],
        'run_part': DIALOGUE['run_part'],
        'abs_time': '',  # the absolute time that this trial was started
        
        # Square positions
        'encode': random.sample(range(RECALL_DIMENSIONS_LOCATION[0] * RECALL_DIMENSIONS_LOCATION[1]), span_trial) 
            if DIALOGUE['stimType'] == 'location' 
            else random.sample(stims_cards, span_trial),  # sample without replacement
        'recall_anss': [],  # answers
        'grid_rts': [],  # reaction time to individual presses
        'grid_rt': '',  # total reaction time of recall
        'grid_scores': [],
        'grid_score': '',
        
        # Symmetry task
        'symmetry_image_files': [pattern['recording_filename'] for pattern in patterns_trial],
        'symmetry_symmetrical': [int('_mirror' in pattern['recording_filename']) for pattern in patterns_trial],
        'symmetry_scores': [],  # per-pattern scores
        'symmetry_score': '',  # per-trial summed score
        'symmetry_rts': [],  # per-pattern RT
        'symmetry_rt': '',  # per-trial average RT
        'symmetry_running_correctness': ''
    }
    
    return trial


class csvWriter(object):
    def __init__(self, saveFilePrefix='', saveFolder=''):
        """
        Creates a csv record_file and appends single rows to it using the csvWriter.write() function.
        Use this function to save trials. Writing is very fast. Around a microsecond.

        :saveFilePrefix: a string to prefix the record_file with
        :saveFolder: (string/False) if False, uses same directory as the py record_file

        So you'd do this::
                # In the beginning of your script
                writer = csvWriter('subject 1', 'dataFolder')

                # In the trial-loop
                trial = {'condition': 'fun', 'answer': 'left', 'rt': 0.224}  # your trial
                writer.write(trial)
        
        See lindeloev.net where csvWriter is maintained and new versions will be published.
        """
        import csv, time

        # Create folder if it doesn't exist
        if saveFolder:
            import os
            saveFolder += '/'
            if not os.path.isdir(saveFolder):
                os.makedirs(saveFolder)

        # Generate self.saveFile and self.writer
        self.saveFile = saveFolder + str(saveFilePrefix) + ' (' + time.strftime('%Y-%m-%d %H-%M-%S', time.localtime()) +').csv'  # Filename for csv. E.g. "myFolder/subj1_cond2 (2013-12-28 09-53-04).csv"
        self.writer = csv.writer(open(self.saveFile, 'wb'), delimiter=';').writerow  # The writer function to csv. It appends a single row to record_file
        self.headerWritten = False

    def write(self, trial):
        """:trial: a dictionary"""
        if not self.headerWritten:
            self.headerWritten = True
            self.writer(trial.keys())
        self.writer(trial.values())


def ask(text='', keyList=None, textstim=instruct_center):
    """
    Ask subject something. Shows question and returns answer (keypress)
    and reaction time. Defaults to no text and all keys.
    """
    # Wait for mouse release
    while mouse.getPressed()[0]:
        pass    
    
    # Draw the TextStims to visual buffer, then show it and reset timing immediately (at stimulus onset)
    textstim.text = text
    textstim.draw()
    win.flip()
    clock.reset()
    #core.wait(5)  # Continuing faster than this is not allowed

    # Halt everything and wait for (first) responses matching the keys given in the Q object.
    event.clearEvents()
    while not mouse.getPressed()[0]:
        for key in event.getKeys():  # quit on escape
            if key in KEYS_QUIT:
                core.quit()
    # Wait for mouse release and return
    while mouse.getPressed()[0]:
        pass
    return clock.getTime()

def symmetry_example(text, example_id):
    instruct_image.image = stims_symm['examples'][example_id]['recording_filename']
    instruct_image.draw()
    ask(text, textstim=instruct_bottom)
    
    

def animate_click(stim, background):
    """ Changes the fillColor of a ShapeStim as long as the mouse is pressed on it. """
    stim.fillColor = 'gray'
    background.draw()
    stim.draw()
    win.flip()
    while mouse.isPressedIn(stim):  # wait
        pass
    stim.fillColor = BUTTON_STYLE['fillColor']


def runRecallCard(trial):
    """Recall cards"""
    # PREPERATION
    # Create a list "itemOptions of items to show as response options. All of targets + some fill-ins
    itemFillin = list(set(stims_cards) - set(trial['encode']))  # allowable fill-in response options (non-targets)
    itemFillin = random.sample(itemFillin, len(gridCoords) - trial['span'])  # selected fill-in items
    itemOptions = trial['encode'] + itemFillin  # items for this answer
    itemOptions = random.sample(itemOptions, len(itemOptions))  # randomize order
    
    # Create a BufferImageStim "grid" with an array of target and fill-in faces or letters
    screen_buttons.draw()
    for i, item in enumerate(itemOptions):
        recallOption.pos = gridCoords[i]  # set position
        recallOption.image = item
        recallOption.draw()
    
    textRecall.text = u'Select ' + str(trial['span']) + u' items in their correct position in the presented sequence.\nPress SPACE to select and deselect. Press RETURN to submit answer.'
    textRecall.draw()    
    grid = visual.BufferImageStim(win)  # take screenshot of back buffer
    win.clearBuffer()  # clear back buffer
    
    # ACTUAL RECALL
    win.callOnFlip(clock.reset)  # reset clock on next flip
    
    while True:
        # Draw images
        grid.draw()
        
        # Overlay current selection state
        for i, thisSelection in enumerate(trial['recall_anss']):
            # Color overlay
            recallSelectedOverlay.pos = gridCoords[thisSelection]
            recallSelectedOverlay.draw()
            
            # Sequence number
            numCoord = gridCoords[thisSelection] + [1, -1] * recallOption.size * 0.3  # location off-center
            recallSelectedNumber.pos = numCoord
            recallSelectedNumber.text = i + 1  # show 1, 2, 3, etc. and not 0, 1, 2
            recallSelectedNumber.draw()
        
        # Show everything!
        win.flip()
        while mouse.getPressed()[0]:
            pass

        # Wait for response. On every mouse press, update the textfield until keysAns is pressed
        wait_response = True
        while wait_response:
            for i, coord in enumerate(gridCoords):
                recallSelectedOverlay.pos = coord
                if mouse.isPressedIn(recallSelectedOverlay):
                    wait_response = False
                    if i in trial['recall_anss']:
                        # Remove this index
                        index = trial['recall_anss'].index(i)
                        trial['recall_anss'].pop(index)
                        trial['grid_rts'].pop(index)
                    elif len(trial['recall_anss']) < trial['span']:  # only allow more answers if span is not reached
                        # Add to the end
                        trial['recall_anss'] += [i]
                        trial['grid_rts'] += [clock.getTime()]

            # Check buttons
            status, trial = check_recall_buttons(trial)
            if status == 'respond':
                # Answer submitted. Record and score response
                trial['recall_anss'] = [itemOptions[index] for index in trial['recall_anss']]  # convert indicies to image filenames for the datafile
                trial = scoreCS(trial)
                return trial  # finished!
            elif status:
                break  # break out of the while loop in order to re-draw everything             
            
            # Exit button
            if event.getKeys(keyList=KEYS_QUIT):
                core.quit()
                

def runRecallLocation(trial):
    rts = []
    win.callOnFlip(clock.reset)
    continue_recall = True
    while continue_recall:
        # Present grid with current selections and sequence numbers
        screen_recall_grid.draw()
        for i, pos in enumerate(trial['recall_anss']):                
            if pos is not -1: # blank trial
                square_target.pos = grid_coords[pos]
                square_target.draw()
                text_target.pos = grid_coords[pos]
                text_target.text = i + 1  # potentially slow
                text_target.draw()
        
        
        # Flip and wait for mouse release if it's still pressed in
        win.flip()
        while mouse.getPressed()[0]:
            pass
        
        # Get new responses. A continuous loop to capture mouse presses everywhere at everytime.
        continue_response = True
        while continue_response:
            if event.getKeys(keyList=KEYS_QUIT):
                core.quit()
            # Draw grid and react to grid selections. Takes ~1 ms for 16 locations
            for i, pos in enumerate(grid_coords):
                square_grid.pos = pos
                # This square is pressed, register response
                if mouse.isPressedIn(square_grid):
                    if i in trial['recall_anss']:
                        # Remove this index
                        index = trial['recall_anss'].index(i)
                        trial['recall_anss'].pop(index)
                        trial['grid_rts'].pop(index)
                    elif len(trial['recall_anss']) < trial['span']:  # ignore if this cell is already selected
                        trial['recall_anss'] += [i]
                        trial['grid_rts'] += [clock.getTime()]
                        rts += [clock.reset]
                    continue_response = False
                    break  # to leave square_grid at it's position
            
            status, trial = check_recall_buttons(trial)
            if status == 'respond':
                # Answer submitted. Record and score response
                trial = scoreCS(trial)
                return trial


def check_recall_buttons(trial):
    """Check and react to button presses.
    Returns (status, trial) where status is either 'respond', 'blank', or 'clear'
    """
    background = screen_recall_grid if trial['stimType'] == 'location' else screen_buttons  # which background during animations
    
    status = None
    if mouse.isPressedIn(recall_button_respond):
        # Summarize recall
        trial['grid_rt'] = clock.getTime()
        trial['recall_anss'] += [-2]*(trial['span'] - len(trial['recall_anss']))  # fill in response if there are missing responses
        trial['grid_scores'] += [int(trial['recall_anss'][i] == trial['encode'][i]) for i in range(len(trial['encode']))]  # score
        trial['grid_score'] = sum(trial['grid_scores'])
        
        # Continue
        animate_click(recall_button_respond, background)
        
        status = 'respond'
    elif mouse.isPressedIn(recall_button_clear):
        trial['recall_anss'] = []
        trial['grid_rts'] = []
        trial['grid_scores'] = []
        animate_click(recall_button_clear, background)

        status = 'clear'
    elif mouse.isPressedIn(recall_button_blank) and len(trial['recall_anss']) < trial['span']:
        trial['recall_anss'] += [-1]
        trial['grid_rts'] += [clock.getTime()]
        trial['grid_scores'] += [0]
        animate_click(recall_button_blank, background)
        
        status = 'blank'
    
    return status, trial

allRecallLocationScores = []
def scoreCS(trial):
    """Given trial['encode'] and trial['recallAns'], score trial."""
    global allRecallLocationScores
    intersection = [encode for encode in trial['encode'] if encode in trial['recall_anss']]
    location = [encode for i, encode in enumerate(trial['encode']) if encode == trial['recall_anss'][i]]  # for every stim presented, check if it corresponds to the answer given.
    
    allRecallLocationScores += [1]*len(location) + [0]*(trial['span'] - len(location))
    trial['recallLocationRateCumulative'] = sum(allRecallLocationScores) / len(allRecallLocationScores)
    trial['recallLocation'] = len(location)
    trial['recallIntersection'] = len(intersection)
    trial['recallSum'] = len(intersection) + len(location)
    trial['recallProportion'] = len(location) / trial['span']
    trial['symmetryProportion'] = sum(trial['symmetry_scores']) / trial['span']
    
    return trial


symmetry_correctness = []
def run_trial(span=None, run_section=None):
    """
    Runs a block of trials.
    run_section is either None (run all), 'grid' or 'symmetry'
    spans is a list of ints with specific spans to run
    """
    global symmetry_correctness
    
    # Loop through trials        
    trial = make_trial(span, run_section)
    trial['abs_time'] = core.getAbsTime()
    # Prepare trial
    for i, image in enumerate(trial['symmetry_image_files']):
        stim_symm[i].image = image
    if trial['stimType'] == 'card':
        for i, image in enumerate(trial['encode']):
            stim_card[i].image = image
            
    
    # Encoding and procesing
    for i in range(trial['span']):
        if run_section in ('grid', None):
            # Show grid and target
            if trial['stimType'] == 'location':
                square_target.pos = grid_coords[trial['encode'][i]]
                for frame in range(GRID_DURATION):
                    grid.draw()
                    square_target.draw()
                    win.flip()
            elif trial['stimType'] == 'card':
                for frame in range(GRID_DURATION):
                    stim_card[i].draw()
                    win.flip()
            
            # Pause
            for frame in range(GRID_PAUSE):
                win.flip()
        
        if run_section in ('symmetry', None):
            # Present symmetry task and wait for mouse response
            stim_symm[i].draw()
            win.flip()
            while not mouse.getPressed()[0]:
                pass
            
            # Break before response
            for frame in range(SYMM_PAUSE):
                win.flip()
    
            # Show symmetry response screen and wait for mouse release 
            # before continuing to get response
            screen_symmetry.draw()
            win.flip()
            clock.reset()
            while mouse.getPressed()[0]:
                pass
        
            while True:
                # Wait and score trial on mouse press
                if  mouse.isPressedIn(symm_button_yes):
                    trial['symmetry_rts'] += [clock.getTime()]
                    trial['symmetry_scores'] += [int(trial['symmetry_symmetrical'][i] == 1)]
                    clock.reset()
                    animate_click(symm_button_yes, screen_symmetry)
                    break
                if mouse.isPressedIn(symm_button_no):
                    trial['symmetry_rts'] += [clock.getTime()]
                    trial['symmetry_scores'] += [int(trial['symmetry_symmetrical'][i] == 0)]
                    animate_click(symm_button_no, screen_symmetry)
                    break
        
    # Recall
    event.clearEvents()
    if run_section in ('grid', None):
        if trial['stimType'] == 'card':
            trial = runRecallCard(trial)
        elif trial['stimType'] == 'location':
            trial = runRecallLocation(trial)
    
    # Feedback
    instruct_center.text = ''
    if run_section in ('grid', None):
        instruct_center.text = TEXT_FEEDBACK_GRID %(trial['recallLocation'], trial['span'])
    if run_section in ('symmetry', None):
        # Summarize symmetry
        trial['symmetry_score'] = sum(trial['symmetry_scores'])
        trial['symmetry_rt'] = sum(trial['symmetry_rts'])
        symmetry_correctness += trial['symmetry_scores']
        trial['symmetry_running_correctness'] = int(100*(sum(symmetry_correctness) / len(symmetry_correctness)))
        instruct_center.text += TEXT_FEEDBACK_SYMMETRY % (trial['span'] - trial['symmetry_score'])
        feedback_percent.text = TEXT_FEEDBACK_PERCENT % trial['symmetry_running_correctness']
    for frame in range(FEEDBACK_DURATION):
        feedback_percent.draw()
        instruct_center.draw()
        win.flip()
    
    # Save
    writer.write(trial)
    return trial
    

def run_training(span_training):
    clock_absolute.reset()
    
    # Keep going for the duration of the training
    while clock_absolute.getTime() < TIME_TRAINING:
        trial = run_trial(span=span_training)
        
        # If performance is outside the 
        if trial['recallProportion'] < DOWNGRADE_CRITERION and span_training - 1 >= 2:  # span cannot be lower than 2 (must be able to subtract -1 due to randomness)
            span_training -= 1
        elif trial['recallProportion'] > UPGRADE_CRITERION:
            span_training += 1

            
"""
EXCECUTE
"""
writer = csvWriter(DIALOGUE['id'] + '_trials', saveFolder=SAVE_FOLDER) # writer.write(trial) will write individual trials with low latency

# -----------------

if DIALOGUE['run_part'] == 'instructionText':
    # Welcome practice recall
    ask(INSTRUCT_WELCOME1)
    ask(INSTRUCT_RECALL1)
    ask(INSTRUCT_RECALL2)
    run_trial(run_section='grid', span=2)
    run_trial(run_section='grid', span=2)
    run_trial(run_section='grid', span=3)
    
    # Instructions for symmetry task
    ask(INSTRUCT_SYMMETRY1)
    symmetry_example(INSTRUCT_SYMMETRY2, 0)
    symmetry_example(INSTRUCT_SYMMETRY3, 1)
    symmetry_example(INSTRUCT_SYMMETRY4, 2)
    ask(INSTRUCT_SYMMETRY5)
    run_trial(run_section='symmetry', span=1)
    run_trial(run_section='symmetry', span=3)
    
    # Practice both
    ask(INSTRUCT_TASK1)
    ask(INSTRUCT_TASK2)
    ask(INSTRUCT_TASK3)
    run_trial(span=2)
    run_trial(span=3)

elif DIALOGUE['run_part'] == 'test':
    span_sequence = SPANS_TEST * N_REPS
    random.shuffle(span_sequence)
    for span in span_sequence:
        run_trial(span=span)

elif DIALOGUE['run_part'] == 'training':
    run_training(2)
    
# Bye bye, have a good one
ask(INSTRUCT_BYE)